---
sidebar_position: 6
---

# 搭建使用了引擎的编辑器

在本文中，您将学习到：

- 如何在编辑器中使用引擎来渲染3D场景
- 如何在编辑器中加入GameObject到3D场景中

我们将搭建的编辑器会有一个Scene View控件和一个Button控件。前者会显示渲染的3D场景，后者可加入新的Cube到场景中。另外，场景中加入了Arcball轨道相机，从而可以旋转观看场景。

在线运行的截图如下：
![运行结果.png](/img/搭建使用了引擎的编辑器/运行结果.png)

在线Demo在[这里](https://meta3d-platform-production.4everland.app/EnterApp?account=0xf63e1991a343814ede505d7cfc368615eae75307&appName=%E7%BC%96%E8%BE%91%E5%99%A8demo1)

下面我们来一步步操作：
## 搭建和发布editor-engine-render包

因为在编辑器中的引擎的相关逻辑有了一些变化（如窗口大小现在变为Scene View控件的大小了；并且要处理轨道相机的事件）我们需要对之前的引擎相关的包进行修改，只保留basic、scene包，替换render和whole包

现在我们搭建editor-engine-render包

该包需要下面的扩展：
- meta3d-editor-engine-render（实现的协议名：meta3d-editor-engine-render-protocol）
该扩展为入口扩展
- webgl1（实现的协议名：webgl1 protocol）

该包需要下面的贡献：
- meta3d-pipeline-editor-viewrect（实现的协议名：meta3d-pipeline-editor-viewrect-protocol）
该贡献属于Pipeline类型，包含了获得Scene View控件的大小作为窗口大小的Job
- meta3d-pipeline-editor-webgl1-getgl（实现的协议名：meta3d-pipeline-webgl1-creategl-protocol）
该贡献属于Pipeline类型，包含了将IMGUI的webgl1上下文设为渲染webgl1的上下文
- meta3d-pipeline-webgl1-detectgl（实现的协议名：meta3d-pipeline-webgl1-detectgl-protocol）
- meta3d-pipeline-webgl1-geometry（实现的协议名：meta3d-pipeline-webgl1-geometry-protocol）
- meta3d-pipeline-webgl1-material（实现的协议名：meta3d-pipeline-webgl1-material-protocol）
- meta3d-pipeline-webgl1-data（实现的协议名：meta3d-pipeline-webgl1-data-protocol）
- meta3d-pipeline-webgl1-senduniformshaderdata（实现的协议名：meta3d-pipeline-webgl1-senduniformshaderdata-protocol）


搭建和发布的流程与[搭建和发布engine-basic包](搭建您的第一个引擎#搭建和发布engine-basic包)一样



## 搭建和发布editor-engine-whole包

现在我们搭建editor-engine-whole包

该包需要下面的扩展：
- meta3d-editor-engine-whole（实现的协议名：meta3d-editor-engine-whole-protocol）
该扩展为入口扩展
- most（实现的协议名：most protocol）
- immutable（实现的协议名：immutable protocol）
- meta3d-engine-core（实现的协议名：meta3d-engine-core）

该包需要下面的贡献：
- meta3d-pipeline-editor-event（实现的协议名：meta3d-pipeline-editor-event-protocol）
该贡献属于Pipeline类型，负责处理事件
- meta3d-pipeline-editor-webgl1-scene-view1（实现的协议名：meta3d-pipeline-webgl1-scene-view1-protocol）
该贡献属于Pipeline类型，负责准备Scene View（如初始化FBO）
- meta3d-pipeline-webgl1-scene-view2（实现的协议名：meta3d-pipeline-webgl1-scene-view2-protocol）
该贡献属于Pipeline类型，负责与Scene View相关的restore的逻辑


该包需要下面的包：
- engine-basic
- engine-scene
- editor-engine-render


我们进行下面的操作：
- 刷新并重新登录
- 进入扩展市场，选择所需的扩展
- 进入贡献市场，选择所需的贡献
- 进入包市场，分别选择将meta3d-engine-basic-protocol, meta3d-engine-scene-protocol, meta3d-editor-engine-render-protocol作为入口扩展协议的包engine-basic, engine-scene, editor-engine-render
- 进入装配空间->包装配
- 依次点击左侧Packages中的3个包一次，将其选中
- 选中所有的扩展
- 将meta3d-editor-engine-whole扩展设为入口扩展
- 发布包



## 获得需要的扩展、贡献、包

这个编辑器需要下面的扩展：
- event（实现的协议名：event protocol）
- imgui-webgl1-renderer（实现的协议名：renderer protocol）
- ui（实现的协议名：ui protocol）
- meta3d-editor-run-engine（实现的协议名：run engine protocol）
- meta3d-use-editor（实现的协议名：use editor protocol）
该扩展为应用的启动扩展

这个编辑器需要下面的贡献：
- add-cube（实现的协议名：add cube action protocol）
该贡献属于Action类型，负责处理add cube事件
- window（实现的协议名：window protocol）
- button（实现的协议名：button protocol）
- scene view（实现的协议名：scene view protocol）
该贡献属于UIControl类型，调用了ui扩展中关于Scene View的绘制API

这个编辑器需要下面的包：
- editor-engine-whole（入口扩展协议名：
meta3d-editor-engine-whole-protocol）


我们从扩展市场和贡献市场、包市场中选择它们





## 搭建编辑器页面

现在我们来可视化地搭建编辑器页面，绑定数据和Action：
- 进入装配空间，在左侧的Packages中，点击whole包一次从而选中它
- 依次选中所有的扩展和贡献
- 设置页面的宽度为800px，高度为600px
- 进入Element装配
- 点击UI Controls中的Window控件一次，将其加入到页面上
- 点击左侧的Selected UI Controls，点击选中的Window控件
- 在右侧的控件面板中，设置Rect的第三行第一个input（对应Width）的值为200，设置第四行第一个input（对应Height）的值为200，从而将Window的宽和高设为200,200
- 点击UI Controls中的Button控件一次，将其加入到Window中，作为child（现在Button会跟随Window移动）
- 点击左侧的Selected UI Controls中Window前方的箭头，从而显示出它的child:Button
- 点击该Button，设置Rect的第二行第一个input（对应PositionY）的值为60
- 继续设置控件面板最下方的Event，选择AddCube
从而监听了click事件，将事件handler与Action贡献绑定了
- 点击左侧的Selected UI Controls，点击root
- 点击UI Controls中的Scene View控件一次，将其加入到页面上（也就是作为root的child）
- 在右侧的控件面板中，设置Rect的第三行第一个input（对应Width）的值为200，设置第四行第一个input（对应Height）的值为200，从而将Scene View的宽和高设为200,200
- 继续设置Rect的第二行第一个input（对应PositionY）的值为333




## 运行编辑器页面

点击运行按钮，出现运行页面

可进行下面的操作来测试：
在Scene View中可拖动相机；
点击Button按钮，可加入一个Cube。


## 剩余的步骤

剩余的步骤的操作方法跟[搭建您的第一个编辑器](搭建您的第一个编辑器)中一样，具体有下面的步骤：
- 发布编辑器页面
- 选择编辑器页面贡献
- 搭建编辑器
- 发布编辑器
- 运行编辑器

最后我们看到成功运行了该编辑器