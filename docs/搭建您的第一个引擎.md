---
sidebar_position: 4
---

# 搭建您的第一个引擎

在本文中，您将学习到：

- 如何搭建引擎包
- 如何下载引擎包
- 如何在本地使用引擎包


引擎就是一个包

我们将搭建一个基于WebGL1的最简单的引擎包


我们将在本地使用引擎包来绘制一个立方体，运行的截图如下：
![渲染结果.png](/img/搭建您的第一个引擎/渲染结果.png)


## 先决条件

您需要先登录，具体请参考：[如何登录](TODO)


下面我们来一步步操作：
## 搭建和发布engine-basic包

引擎包由3个更小的包组成：
- engine-basic包
包含最基础的扩展和贡献
- engine-scene包
包含构建3D场景所需要的的扩展和贡献
- engine-render包
包含渲染所需要的的扩展和贡献

现在我们首先搭建engine-basic包

该包需要下面的扩展：
- meta3d-engine-basic（实现的协议名：meta3d-engine-basic-protocol）
该扩展为入口扩展

该包需要下面的贡献：
- meta3d-pipeline-root（实现的协议名：meta3d-pipeline-root-protocol）
该贡献属于Pipeline类型，包含了所有Pipeline贡献的根Job

我们首先从扩展市场和贡献市场中选择它们；
然后进入装配空间后，点击下图红框进入包装配：
![进入包装配.png](/img/搭建您的第一个引擎/进入包装配.png)

然后选中所有的扩展和贡献；

然后将meta3d-engine-basic扩展设置为入口扩展：
![设为入口扩展.png](/img/搭建您的第一个引擎/设为入口扩展.png)

最后点击发布按钮，输入包名：engine-basic、包版本号、包介绍，点击发布按钮发布到包市场：
![发布engine-basic包.png](/img/搭建您的第一个引擎/发布engine-basic包.png)


## 搭建和发布engine-scene包

现在我们搭建engine-scene包

该包需要下面的扩展：
- meta3d-engine-scene（实现的协议名：meta3d-engine-scene-protocol）
该扩展为入口扩展

该包需要下面的贡献：
- meta3d-component-transform（实现的协议名：meta3d-component-transform-protocol）
该贡献属于Component类型，定义了Transform组件
- meta3d-component-geometry（实现的协议名：meta3d-component-geometry-protocol）
该贡献属于Component类型，定义了Geometry组件
- meta3d-component-pbrmaterial（实现的协议名：meta3d-component-pbrmaterial-protocol）
该贡献属于Component类型，定义了PBRMaterial组件
- meta3d-component-basiccameraview（实现的协议名：meta3d-component-basiccameraview-protocol）
该贡献属于Component类型，定义了BasicCameraView组件
- meta3d-component-perspectivecameraprojection（实现的协议名：meta3d-component-perspectivecameraprojection-protocol）
该贡献属于Component类型，定义了PerspectiveCameraProjection组件
- meta3d-component-arcballcameracontroller（实现的协议名：meta3d-component-arcballcameracontroller-protocol）
该贡献属于Component类型，定义了ArcballCameraController组件
- meta3d-gameobject（实现的协议名：meta3d-gameobject-protocol）
该贡献属于GameObject类型，定义了GameObject
- meta3d-pipeline-camera（实现的协议名：meta3d-pipeline-camera-protocol）
该贡献属于Pipeline类型，包含了更新Camera相关的PerspectiveCameraProjection组件、ArcballCameraController组件的Job
- meta3d-pipeline-transform（实现的协议名：meta3d-pipeline-transform-protocol）
该贡献属于Pipeline类型，包含了更新Transform组件的Job

搭建和发布的流程与engine-basic包一样，只是在操作前先刷新一下并重新登录，这样可避免选择了engine-basic包的扩展和贡献


## 搭建和发布engine-render包

现在我们搭建engine-render包

该包需要下面的扩展：
- meta3d-engine-render（实现的协议名：meta3d-engine-render-protocol）
该扩展为入口扩展
- webgl1（实现的协议名：webgl1 protocol）

该包需要下面的贡献：
- meta3d-pipeline-viewrect（实现的协议名：meta3d-pipeline-viewrect-protocol）
该贡献属于Pipeline类型，包含了获得窗口大小的Job
- meta3d-pipeline-webgl1-creategl（实现的协议名：meta3d-pipeline-webgl1-creategl-protocol）
该贡献属于Pipeline类型，包含了拿到webgl1的上下文的Job
- meta3d-pipeline-webgl1-detectgl（实现的协议名：meta3d-pipeline-webgl1-detectgl-protocol）
该贡献属于Pipeline类型，包含了检测webgl1的扩展的Job
- meta3d-pipeline-webgl1-geometry（实现的协议名：meta3d-pipeline-webgl1-geometry-protocol）
该贡献属于Pipeline类型，包含了初始化Geometry组件的Job
- meta3d-pipeline-webgl1-material（实现的协议名：meta3d-pipeline-webgl1-material-protocol）
该贡献属于Pipeline类型，包含了初始化PBRMaterial组件的Job
- meta3d-pipeline-webgl1-data（实现的协议名：meta3d-pipeline-webgl1-data-protocol）
该贡献属于Pipeline类型，包含了渲染数据相关的Job
- meta3d-pipeline-webgl1-senduniformshaderdata（实现的协议名：meta3d-pipeline-webgl1-senduniformshaderdata-protocol）
该贡献属于Pipeline类型，包含了发送相机数据的Job

搭建和发布的流程与engine-scene包一样


## 搭建和发布engine-whole包

现在我们搭建引擎包：engine-whole包

该包需要下面的扩展：
- meta3d-engine-whole（实现的协议名：meta3d-engine-whole-protocol）
该扩展为入口扩展
- most（实现的协议名：most protocol）
- immutable（实现的协议名：immutable protocol）
- meta3d-engine-core（实现的协议名：meta3d-engine-core）
该扩展为引擎的核心扩展，它需要Component、GameObject、Pipeline类型的贡献来扩展


该包需要下面的包：
- engine-basic
- engine-scene
- engine-render


我们进行下面的操作：
- 刷新并重新登录
- 进入扩展市场，选择所需的扩展
- 进入包市场，分别选择将meta3d-engine-basic-protocol, meta3d-engine-scene-protocol, meta3d-engine-render-protocol作为入口扩展协议的包engine-basic, engine-scene, engine-render
- 进入装配空间->包装配
- 依次点击左侧Packages中的3个包一次，将其选中
- 选中所有的扩展
- 将meta3d-engine-whole扩展设为入口扩展
- 发布包






## 下载engine-whole包

进入包市场，下载将meta3d-engine-whole-protocol作为入口扩展协议的包engine-whole


## 在本地使用engine-whole包来绘制一个立方体

调用engine-whole包的代码可以参考Meta3D提供的示例:[use-package2](https://github.com/Meta3D-Technology/Meta3D/tree/master/examples/use-package2)

使用该示例的步骤如下所示：

首先获得 [Meta3D](https://github.com/Meta3D-Technology/Meta3D)的代码；


然后在项目根目录上执行下面的命令：
```js
npm run bootstrap
```

然后将下载的engine-whole包放到examples/use-package2/src/packages/中；

然后修改examples/use-package2/src/Main.ts中的包路径的代码：
```js
将这行中的路径:
import * as packageBinaryFile from "arraybuffer-loader!../mine/engine-whole_0.0.1.package"
修改为你的包路径，如：
import * as packageBinaryFile from "arraybuffer-loader!./packages/engine-whole_0.0.1.package"
```

最后进入examples/use-package2/，执行下面的命令：
```js
npm run webpack:dev-server
```


可以在浏览器中看到渲染成功
